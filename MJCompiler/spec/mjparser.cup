

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
	
	/******* parser error handling ********/
	
	boolean errorDetected;
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      errorDetected = true;
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
    	errorDetected = true;
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
    	errorDetected = true;
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

	/***************************************/
:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/******************* terminals ***********************/

terminal PROGRAM, BREAK, CLASS, ENUM, ELSE, CONST, IF, DO, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOREACH;

terminal String IDENT;
terminal Integer NUM_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;

terminal PLUS, MINUS, MUL, DIV, PERCENT, DEQ, NE, GT, GE, LT, LE, AND, OR, EQ, INC, DEC;
terminal SEMICOLON, COLON, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE, LAMBDA;

/******************* nonterminals **********************/

/* Program */
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramName, Program;
nonterminal GlobalDeclList, GlobalMethodDeclList;

/* ConstDecl */
nonterminal ConstDecl, OtherConstDeclarations;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Constant;

/* VarDecl */
nonterminal VarDecl, NewVarDecl, OptionalVarDeclList, OptionalSquare;
nonterminal Class_VarDecl, Class_NewVarDecl, Class_OptionalVarDeclList;
nonterminal Global_VarDecl, Global_NewVarDecl, Global_OptionalVarDeclList;

/* ClassDecl */
nonterminal ClassDecl, ClassBody, Dummy_ClassBody, Class_VarDeclList, ConstructorMethodLists, ClassMethodConstructorLists, MethodDeclList;
nonterminal ConstructorDeclList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ClassNameAndDerivation;
nonterminal rs.etf.pp1.symboltable.concepts.Struct OptionalDerivation;

/* ConstructorDecl */
nonterminal ConstructorDecl, FormParsOptional, StatementList, VarDeclList;

/* MethodDecl */
nonterminal MethodDecl;

/* FormPars */
nonterminal FormPars, OneFormPar, TypeIdentList;

/* Type */
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

/* Statement */
nonterminal Statement, Unmatched, Matched, OptionalExpr, PrintNumConst, DesignatorForeach;

/* DesignatorStatement */
nonterminal DesignatorStatement, DesignatorOptions, OptionalDesignatorList, OptionalActPars, OptionalDesignator, DesignatorList;
		 
/* ActPars */
nonterminal ActPars, ExprList;

/* Condition */
nonterminal Condition, ConditionIf, ConditionWhile, Or_CondTermList;

/* CondTerm */
nonterminal CondTerm, And_CondFactList;

/* CondFact */
nonterminal CondFact, OptionalRelopExpr;

/* Expr */
nonterminal Expr, OptionalMinus, AddopTermList;

/* Term */
nonterminal Term, MulopFactorList;

/* Factor */
nonterminal Factor, OptionalActParsParen, ExprActPars, ParenWithOptionalActPars;

/* Designator */
nonterminal Designator, IdentExprList;

/* Label */
nonterminal Label;

/* Assignop */
nonterminal Assignop;

/* Relop */
nonterminal Relop;

/* Addop */
nonterminal Addop;

/* Mulop */
nonterminal Mulop;

/****************** precedence ************************/

precedence left ELSE;

/************************ grammar **********************/

/***** Program ******/

Program ::= (Program_) PROGRAM ProgramName GlobalDeclList LBRACE GlobalMethodDeclList RBRACE;

ProgramName ::= (ProgramName) IDENT:programName;

GlobalDeclList ::= (GlobalDeclListConst) 	GlobalDeclList ConstDecl 
				 | (GlobalDeclListVar) 		GlobalDeclList Global_VarDecl   
				 | (GlobalDeclListClass) 	GlobalDeclList ClassDecl 
				 | (EmptyGlobalDeclList) 	/* empty */
				 ;
				  
GlobalMethodDeclList ::= (GlobalMethodDeclList_Void) 	GlobalMethodDeclList VOID IDENT LPAREN MethodDecl 
					   | (GlobalMethodDeclList_Ident) 	GlobalMethodDeclList IDENT IDENT LPAREN MethodDecl
				   	   | (EmptyGlobalMethodDeclList) 	/* empty */
				   	   ;
				   	   
/***** ConstDecl *******/		   
				   
ConstDecl ::= (ConstDecl) CONST Type IDENT:firstIdentName EQ Constant OtherConstDeclarations SEMICOLON ;

Constant ::= 	(NumConstant) 	NUM_CONST:value
		   	|   (CharConstant) 	CHAR_CONST:value
			|   (BoolConstant) 	BOOL_CONST:value
			;
			   
OtherConstDeclarations ::= 	(OtherConstDeclarations_) 	OtherConstDeclarations COMMA IDENT:identName EQ Constant 
						|	(NoOtherConstDeclatations) 	/* empty */
						;

/******** VarDecl **********/
				   
VarDecl ::= (VarDecl) Type NewVarDecl OptionalVarDeclList SEMICOLON;

NewVarDecl ::= (NewVarDecl_) IDENT:varName OptionalSquare;

				 
OptionalVarDeclList ::= (OptionalVarDeclList_) 		OptionalVarDeclList COMMA NewVarDecl
					 | 	(EmptyOptionalVarDeclList) 	/* empty */
					 ;
					 
Global_VarDecl ::= (Global_VarDecl) Type Global_NewVarDecl Global_OptionalVarDeclList SEMICOLON;

Global_NewVarDecl ::= (Global_NewVarDecl_) 		IDENT:varName OptionalSquare
			|  (ERROR_NewGlobalVarDecl) 	error:l {: parser.report_error("Greska pri deklaraciji globalne promenljive u liniji: " + lleft, null); :}
			;

				 
Global_OptionalVarDeclList ::= (Global_OptionalVarDeclList_) 		Global_OptionalVarDeclList COMMA Global_NewVarDecl
					 | 	(Global_EmptyOptionalVarDeclList) 	/* empty */
					 |	(ERROR_OptinalGlobalVarDeclList)	error:l {: parser.report_error("Greska pri deklaraciji globalne promenljive u liniji: " + lleft, null); :}
					 ;
					 
OptionalSquare ::= (OptionalSquare_) 	LSQUARE RSQUARE
				|  (NoSquare) 			/* empty */
				;
				
/* class variable declaration (error handling) */
/* note that COMMA is not a safe symbol */

Class_VarDecl ::= (Class_VarDecl_) 		Type Class_NewVarDecl Class_OptionalVarDeclList SEMICOLON
				| (ERROR_Class_VarDecl)	error:l {: parser.report_error("Greska pri deklarisanju polja klase u liniji " + lleft, null); :}
				;	

Class_NewVarDecl ::= (Class_NewVarDecl) IDENT:varName OptionalSquare;

Class_OptionalVarDeclList ::= 	(Class_OptionalVarDeclList_) 		Class_OptionalVarDeclList COMMA Class_NewVarDecl
					 		| 	(Class_EmptyOptionalVarDeclList) 	/* empty */
							;

/*********** ClassDecl **********/

ClassDecl ::= (ClassDecl) ClassNameAndDerivation LBRACE ClassBody RBRACE;

ClassNameAndDerivation ::= (ClassNameAndDerivation) CLASS IDENT:className OptionalDerivation;

ClassBody ::= (ClassBody) Class_VarDeclList Dummy_ClassBody ConstructorMethodLists;

Dummy_ClassBody ::= (Dummy_ClassBody_) /* empty */;

Class_VarDeclList ::= 	(Class_VarDeclList_) 		Class_VarDeclList Class_VarDecl
					| 	(Class_EmptyVarDeclList) 	/* empty */
					;

OptionalDerivation ::= 	(OptionalDerivation_) 	EXTENDS Type
					|	(NoDerivation) 			/* empty */
					|	(ClassDerivation) 		error:l {: parser.report_error("Greska pri parsiranju deklaracije prosirenja natklase u liniji: " + lleft, null); :}
					;
				
ConstructorMethodLists ::= 	(ConstructorMethodLists_) 		LBRACE ClassMethodConstructorLists RBRACE 
						|	(EmptyConstructorMethodLists) 	/* empty */
						;

/* resolving method-constructor parsing conflict  */
ClassMethodConstructorLists ::= (ConstructorsAndMethods_Ident) 	IDENT LPAREN ConstructorDeclList IDENT IDENT LPAREN MethodDeclList 
							 | 	(ConstructorsAndMethods_Void) 	IDENT LPAREN ConstructorDeclList VOID IDENT LPAREN MethodDeclList 
							 | 	(Constructors) 					IDENT LPAREN ConstructorDeclList 
							 | 	(Methods_Ident) 				IDENT IDENT LPAREN MethodDeclList
							 | 	(Methods_Void) 					VOID IDENT LPAREN MethodDeclList
							 | 	(EmptyClassMethodConstructorLists) /* empty */
							 ;

MethodDeclList ::= (MethodDeclList_Ident) 	MethodDeclList IDENT IDENT LPAREN MethodDecl
				 | (MethodDeclList_Void) 	MethodDeclList VOID IDENT LPAREN MethodDecl
				 | (OneMethodDecl) 			MethodDecl
				 ;

ConstructorDeclList ::= (ConstructorDeclList_) 	ConstructorDeclList IDENT LPAREN ConstructorDecl
					  |	(NoConstructorDeclList) ConstructorDecl
					  ;
						
/****** ConstructorDecl *****/

/* note that IDENT LPAREN is already parsed */
ConstructorDecl ::= FormParsOptional RPAREN VarDeclList LBRACE StatementList RBRACE;

VarDeclList ::= (VarDeclList_) 				VarDeclList VarDecl
			| 	(EmptyClassVarDeclList) 	/* empty */
			;

FormParsOptional ::= 	(FormPars_) 	FormPars
					| 	(NoFormPars) 	/* empty */
					;
					
StatementList ::= (StatementList_) 		StatementList Statement
				| (EmptyStatementList) 	/* emptt */
				;

/****** MethodDecl **********/

/* note that IDENT/VOID IDENT LPAREN is already parsed */
MethodDecl ::= FormParsOptional RPAREN VarDeclList LBRACE StatementList RBRACE; 

/************ FormPars ********/

FormPars ::= (FormPars) OneFormPar TypeIdentList;

OneFormPar ::= 	(OneFormPar_) Type IDENT OptionalSquare
			|	(ERROR_OneFormPar) error:l {: parser.report_error("Greska pri deklaraciji formalnog parametra funkcije u liniji " + lleft, null); :}
			;
					
TypeIdentList ::= (TypeIdentList_) 		TypeIdentList COMMA OneFormPar
				| (EmptyTypeIdentList) 	/* empty */
				;
				  
/******** Type *****/

Type ::= (Type) IDENT:typeName;

/******** Statement ********/

Statement ::= (Matched_) Matched
			| (Unmatched_) Unmatched
			;
			  
Unmatched ::= (U_If) 		IF LPAREN ConditionIf RPAREN Statement
			| (U_IfElse) 	IF LPAREN ConditionIf RPAREN Matched ELSE Unmatched
			;

Matched ::= (M_Designator) 	DesignatorStatement
		|	(M_IfElse) 		IF LPAREN ConditionIf RPAREN Matched ELSE Matched 
		|	(M_While) 		WHILE LPAREN ConditionWhile RPAREN Statement 
		|	(M_Break) 		BREAK SEMICOLON 
		|	(M_Continue) 	CONTINUE SEMICOLON 
		|	(M_Return) 		RETURN OptionalExpr SEMICOLON 
		|	(M_Read) 		READ LPAREN Designator RPAREN SEMICOLON 
		|	(M_Print) 		PRINT LPAREN Expr PrintNumConst RPAREN SEMICOLON 
		|	(M_Foreach) 	DesignatorForeach IDENT LAMBDA Statement RPAREN SEMICOLON 
		|	(M_Block) 		LBRACE StatementList RBRACE
		;	

DesignatorForeach ::= (DesignatorForeach) IDENT IdentExprList DOT FOREACH LPAREN;
				 
OptionalExpr ::= (OptionalExpr_) 	Expr 
			|	 (NoExpr) 			/* empty */
			;
				 
PrintNumConst ::= (PrintNumConst_) 	COMMA NUM_CONST 
				| (NoPrintNumConst) /* empty */
				;

/************** DesignatorStatement ***************/

DesignatorStatement ::= (DesignatorWithOptions) 	Designator DesignatorOptions SEMICOLON 
					|	(DesignatorWithSquare) 		LSQUARE OptionalDesignatorList RSQUARE EQ Designator SEMICOLON 
					|	(ERROR_DesignatorStatement) error SEMICOLON:l {: parser.report_error("Greska pri konstrukciji iskaza dodele u liniji " + lleft, null); :}
					;
						
DesignatorOptions ::= 	(Option_Assign) 	Assignop Expr
			|  			(Option_ActPars) 	LPAREN OptionalActPars RPAREN 
			|  			(Option_Inc) 		INC 
			|  			(Option_Dec) 		DEC
			;  
			
OptionalDesignatorList ::= OptionalDesignator DesignatorList;

OptionalActPars ::= (OptionalActPars_) 	ActPars
				 |  (NoOptionalActPars) /* empty */
				 ;
				    
OptionalDesignator ::= (OptionalDesignator_) 	Designator
					 | (NoOptionalDesignator) 	/* empty */
					 ;
					   
DesignatorList ::= (DesignatorList_) 		DesignatorList COMMA OptionalDesignator 
				 | (EmptyDesignatorList) 	/* empty */
				 ;

/******* ActPars ********/

ActPars ::= (ActPars) Expr ExprList;

ExprList ::= (ExprList_) 		ExprList COMMA Expr
		|	 (EmptyExprList) 	/* empty */
		;

/******* Condition *********/

Condition ::= (Condition) 			CondTerm Or_CondTermList;

ConditionIf ::= (ConditionIf_) 		CondTerm Or_CondTermList
			|	(ERROR_ConditionIf) error:l {: parser.report_error("Greska pri parsiranju logickog izraza unutar IF konstrukcije u liniji: " + lleft, null); :}
			;
			
ConditionWhile ::= (ConditionWhile) CondTerm Or_CondTermList;

Or_CondTermList ::= (OrCondTermList) 		Or_CondTermList OR CondTerm 
				 |  (EmptyOrCondTermList) 	/* empty */
				 ;

/******** CondTerm *********/

CondTerm ::= (CondTerm) CondFact And_CondFactList;

And_CondFactList ::= (AndCondFactList) 		And_CondFactList AND CondFact 
				  |	 (EmptyAndCondFactList) /* empty */
				  ;

/********* CondFact **********/

CondFact ::= (CondFact) Expr OptionalRelopExpr;

OptionalRelopExpr ::= (OptionalRelopExpr_) 	Relop Expr 
					| (NoOptionalRelopExpr) /* empty */
					;

/******** Expr *********/

Expr ::= (Expr) OptionalMinus Term AddopTermList;

OptionalMinus ::= 	(OptionalMinus_) 	MINUS
			 	|	(NoMinus) 			/* empty */
			 	;
			 
AddopTermList ::= (AddopTermList_) 		AddopTermList Addop Term
				| (EmptyAddopTermList) 	/* empty */
				;
 				  
/*********** Term *********/

Term ::= (Term) Factor MulopFactorList;

MulopFactorList ::= (MulopFactorList_) 		MulopFactorList Mulop Factor
				|	(EmptyMulopFactorList) 	/* empty */
				;

/*********** Factor **********/

Factor ::= 	(F_DesignatorActPars) 	Designator OptionalActParsParen 
		|   (F_NumConst) 			NUM_CONST 
		|   (F_CharConst) 			CHAR_CONST 
		|   (F_BoolConst) 			BOOL_CONST 
		|   (F_TypeExprActPars) 	NEW Type ExprActPars 
		|   (F_Expr) 				LPAREN Expr RPAREN
		;

OptionalActParsParen ::= 	(OptionalActParsParen_) ParenWithOptionalActPars
				 	| 		(NoActParsParen) 		/* empty */
				 	;

ExprActPars ::= (ExprOrActParsExpr) 	LSQUARE Expr RSQUARE 
			|	(ExprOrActParsActPars) 	ParenWithOptionalActPars
			;
			
ParenWithOptionalActPars ::= (ParenWithOptionalActPars) LPAREN OptionalActPars RPAREN;

/************* Designator ************/

Designator ::= (Designator) IDENT:designatorIdentName IdentExprList;

IdentExprList ::= (IdentExprListIdent) 	IdentExprList DOT IDENT
				| (IdentExprListExpr) 	IdentExprList LSQUARE Expr RSQUARE
				| (EmptyIdentExprList) 	/* empty */
				;
				  
/************* Label ************/

Label ::= (Label) IDENT;

/********** Assignop **********/

Assignop ::= (Assignop) EQ;

/************** Relop ***************/

Relop ::= (R_Deq) 	DEQ 
	|	  (R_Ne) 	NE 
	|	  (R_Gt) 	GT 
	|	  (R_Ge) 	GE 
	|	  (R_Lt) 	LT 
	|	  (R_Le) 	LE
	;
		  
/*********** Addop **********/

Addop ::= (A_Plus) 	PLUS
		| (A_Minus) MINUS
		;
		  
/*********** Mulop **********/

Mulop ::= (M_Mul) 		MUL 
		| (M_Div) 		DIV 
		| (M_Percent) 	PERCENT
		;
