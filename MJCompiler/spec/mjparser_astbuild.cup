

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
	
	/******* parser error handling ********/
	
	boolean errorDetected;
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      errorDetected = true;
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
    	errorDetected = true;
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
    	errorDetected = true;
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

	/***************************************/
:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/******************* terminals ***********************/

terminal PROGRAM, BREAK, CLASS, ENUM, ELSE, CONST, IF, DO, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOREACH;

terminal String IDENT;
terminal Integer NUM_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;

terminal PLUS, MINUS, MUL, DIV, PERCENT, DEQ, NE, GT, GE, LT, LE, AND, OR, EQ, INC, DEC;
terminal SEMICOLON, COLON, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE, LAMBDA;

/******************* nonterminals **********************/

/* Program */
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramName, Program;
nonterminal GlobalDeclList GlobalDeclList;
nonterminal GlobalMethodDeclList GlobalMethodDeclList;

/* ConstDecl */
nonterminal ConstDecl ConstDecl;
nonterminal OtherConstDeclarations OtherConstDeclarations;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Constant;

/* VarDecl */
nonterminal VarDecl VarDecl;
nonterminal NewVarDecl NewVarDecl;
nonterminal OptionalVarDeclList OptionalVarDeclList;
nonterminal OptionalSquare OptionalSquare;
nonterminal Class_VarDecl Class_VarDecl;
nonterminal Class_NewVarDecl Class_NewVarDecl;
nonterminal Class_OptionalVarDeclList Class_OptionalVarDeclList;
nonterminal Global_VarDecl Global_VarDecl;
nonterminal Global_NewVarDecl Global_NewVarDecl;
nonterminal Global_OptionalVarDeclList Global_OptionalVarDeclList;

/* ClassDecl */
nonterminal ClassDecl ClassDecl;
nonterminal ClassBody ClassBody;
nonterminal Dummy_ClassBody Dummy_ClassBody;
nonterminal Class_VarDeclList Class_VarDeclList;
nonterminal ConstructorMethodLists ConstructorMethodLists;
nonterminal ClassMethodConstructorLists ClassMethodConstructorLists;
nonterminal MethodDeclList MethodDeclList;
nonterminal ConstructorDeclList ConstructorDeclList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ClassNameAndDerivation;
nonterminal rs.etf.pp1.symboltable.concepts.Struct OptionalDerivation;

/* ConstructorDecl */
nonterminal ConstructorDecl ConstructorDecl;
nonterminal FormParsOptional FormParsOptional;
nonterminal StatementList StatementList;
nonterminal VarDeclList VarDeclList;

/* MethodDecl */
nonterminal MethodDecl MethodDecl;

/* FormPars */
nonterminal FormPars FormPars;
nonterminal OneFormPar OneFormPar;
nonterminal TypeIdentList TypeIdentList;

/* Type */
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

/* Statement */
nonterminal Statement Statement;
nonterminal Unmatched Unmatched;
nonterminal Matched Matched;
nonterminal OptionalExpr OptionalExpr;
nonterminal PrintNumConst PrintNumConst;
nonterminal DesignatorForeach DesignatorForeach;

/* DesignatorStatement */
nonterminal DesignatorStatement DesignatorStatement;
nonterminal DesignatorOptions DesignatorOptions;
nonterminal OptionalDesignatorList OptionalDesignatorList;
nonterminal OptionalActPars OptionalActPars;
nonterminal OptionalDesignator OptionalDesignator;
nonterminal DesignatorList DesignatorList;
		 
/* ActPars */
nonterminal ActPars ActPars;
nonterminal ExprList ExprList;

/* Condition */
nonterminal Condition Condition;
nonterminal ConditionIf ConditionIf;
nonterminal ConditionWhile ConditionWhile;
nonterminal Or_CondTermList Or_CondTermList;

/* CondTerm */
nonterminal CondTerm CondTerm;
nonterminal And_CondFactList And_CondFactList;

/* CondFact */
nonterminal CondFact CondFact;
nonterminal OptionalRelopExpr OptionalRelopExpr;

/* Expr */
nonterminal Expr Expr;
nonterminal OptionalMinus OptionalMinus;
nonterminal AddopTermList AddopTermList;

/* Term */
nonterminal Term Term;
nonterminal MulopFactorList MulopFactorList;

/* Factor */
nonterminal Factor Factor;
nonterminal OptionalActParsParen OptionalActParsParen;
nonterminal ExprActPars ExprActPars;
nonterminal ParenWithOptionalActPars ParenWithOptionalActPars;

/* Designator */
nonterminal Designator Designator;
nonterminal IdentExprList IdentExprList;

/* Label */
nonterminal Label Label;

/* Assignop */
nonterminal Assignop Assignop;

/* Relop */
nonterminal Relop Relop;

/* Addop */
nonterminal Addop Addop;

/* Mulop */
nonterminal Mulop Mulop;

/****************** precedence ************************/

precedence left ELSE;

/************************ grammar **********************/

/***** Program ******/

Program ::= (Program_) PROGRAM ProgramName:P1 GlobalDeclList:G2 LBRACE GlobalMethodDeclList:G3 RBRACE {: RESULT=new Program_(P1, G2, G3); RESULT.setLine(P1left); :};

ProgramName ::= (ProgramName) IDENT:programName {: RESULT=new ProgramName(programName); RESULT.setLine(programNameleft); :};

GlobalDeclList ::= (GlobalDeclListConst) 	GlobalDeclList:G1 ConstDecl:C2 {: RESULT=new GlobalDeclListConst(G1, C2); RESULT.setLine(G1left); :} 
				 | (GlobalDeclListVar) 		GlobalDeclList:G1 Global_VarDecl:G2 {: RESULT=new GlobalDeclListVar(G1, G2); RESULT.setLine(G1left); :}   
				 | (GlobalDeclListClass) 	GlobalDeclList:G1 ClassDecl:C2 {: RESULT=new GlobalDeclListClass(G1, C2); RESULT.setLine(G1left); :} 
				 | (EmptyGlobalDeclList) {: RESULT=new EmptyGlobalDeclList(); :} 	/* empty */
				 ;
				  
GlobalMethodDeclList ::= (GlobalMethodDeclList_Void) 	GlobalMethodDeclList:G1 VOID IDENT:I2 LPAREN MethodDecl:M3 {: RESULT=new GlobalMethodDeclList_Void(G1, I2, M3); RESULT.setLine(G1left); :} 
					   | (GlobalMethodDeclList_Ident) 	GlobalMethodDeclList:G1 IDENT:I2 IDENT:I3 LPAREN MethodDecl:M4 {: RESULT=new GlobalMethodDeclList_Ident(G1, I2, I3, M4); RESULT.setLine(G1left); :}
				   	   | (EmptyGlobalMethodDeclList) {: RESULT=new EmptyGlobalMethodDeclList(); :} 	/* empty */
				   	   ;
				   	   
/***** ConstDecl *******/		   
				   
ConstDecl ::= (ConstDecl) CONST Type:T1 IDENT:firstIdentName EQ Constant:C2 OtherConstDeclarations:O3 SEMICOLON {: RESULT=new ConstDecl(T1, firstIdentName, C2, O3); RESULT.setLine(T1left); :} ;

Constant ::= 	(NumConstant) 	NUM_CONST:value {: RESULT=new NumConstant(value); RESULT.setLine(valueleft); :}
		   	|   (CharConstant) 	CHAR_CONST:value {: RESULT=new CharConstant(value); RESULT.setLine(valueleft); :}
			|   (BoolConstant) 	BOOL_CONST:value {: RESULT=new BoolConstant(value); RESULT.setLine(valueleft); :}
			;
			   
OtherConstDeclarations ::= 	(OtherConstDeclarations_) 	OtherConstDeclarations:O1 COMMA IDENT:identName EQ Constant:C2 {: RESULT=new OtherConstDeclarations_(O1, identName, C2); RESULT.setLine(O1left); :} 
						|	(NoOtherConstDeclatations) {: RESULT=new NoOtherConstDeclatations(); :} 	/* empty */
						;

/******** VarDecl **********/
				   
VarDecl ::= (VarDecl) Type:T1 NewVarDecl:N2 OptionalVarDeclList:O3 SEMICOLON {: RESULT=new VarDecl(T1, N2, O3); RESULT.setLine(T1left); :};

NewVarDecl ::= (NewVarDecl_) IDENT:varName OptionalSquare:O1 {: RESULT=new NewVarDecl_(varName, O1); RESULT.setLine(varNameleft); :};

				 
OptionalVarDeclList ::= (OptionalVarDeclList_) 		OptionalVarDeclList:O1 COMMA NewVarDecl:N2 {: RESULT=new OptionalVarDeclList_(O1, N2); RESULT.setLine(O1left); :}
					 | 	(EmptyOptionalVarDeclList) {: RESULT=new EmptyOptionalVarDeclList(); :} 	/* empty */
					 ;
					 
Global_VarDecl ::= (Global_VarDecl) Type:T1 Global_NewVarDecl:G2 Global_OptionalVarDeclList:G3 SEMICOLON {: RESULT=new Global_VarDecl(T1, G2, G3); RESULT.setLine(T1left); :};

Global_NewVarDecl ::= (Global_NewVarDecl_) 		IDENT:varName OptionalSquare:O1 {: RESULT=new Global_NewVarDecl_(varName, O1); RESULT.setLine(varNameleft); :}
			|  (ERROR_NewGlobalVarDecl) 	error:l {: parser.report_error("Greska pri deklaraciji globalne promenljive u liniji: " + lleft, null); :} {: RESULT=new ERROR_NewGlobalVarDecl(); :}
			;

				 
Global_OptionalVarDeclList ::= (Global_OptionalVarDeclList_) 		Global_OptionalVarDeclList:G1 COMMA Global_NewVarDecl:G2 {: RESULT=new Global_OptionalVarDeclList_(G1, G2); RESULT.setLine(G1left); :}
					 | 	(Global_EmptyOptionalVarDeclList) {: RESULT=new Global_EmptyOptionalVarDeclList(); :} 	/* empty */
					 |	(ERROR_OptinalGlobalVarDeclList)	error:l {: parser.report_error("Greska pri deklaraciji globalne promenljive u liniji: " + lleft, null); :} {: RESULT=new ERROR_OptinalGlobalVarDeclList(); :}
					 ;
					 
OptionalSquare ::= (OptionalSquare_) 	LSQUARE RSQUARE {: RESULT=new OptionalSquare_(); :}
				|  (NoSquare) {: RESULT=new NoSquare(); :} 			/* empty */
				;
				
/* class variable declaration (error handling) */
/* note that COMMA is not a safe symbol */

Class_VarDecl ::= (Class_VarDecl_) 		Type:T1 Class_NewVarDecl:C2 Class_OptionalVarDeclList:C3 SEMICOLON {: RESULT=new Class_VarDecl_(T1, C2, C3); RESULT.setLine(T1left); :}
				| (ERROR_Class_VarDecl)	error:l {: parser.report_error("Greska pri deklarisanju polja klase u liniji " + lleft, null); :} {: RESULT=new ERROR_Class_VarDecl(); :}
				;	

Class_NewVarDecl ::= (Class_NewVarDecl) IDENT:varName OptionalSquare:O1 {: RESULT=new Class_NewVarDecl(varName, O1); RESULT.setLine(varNameleft); :};

Class_OptionalVarDeclList ::= 	(Class_OptionalVarDeclList_) 		Class_OptionalVarDeclList:C1 COMMA Class_NewVarDecl:C2 {: RESULT=new Class_OptionalVarDeclList_(C1, C2); RESULT.setLine(C1left); :}
					 		| 	(Class_EmptyOptionalVarDeclList) {: RESULT=new Class_EmptyOptionalVarDeclList(); :} 	/* empty */
							;

/*********** ClassDecl **********/

ClassDecl ::= (ClassDecl) ClassNameAndDerivation:C1 LBRACE ClassBody:C2 RBRACE {: RESULT=new ClassDecl(C1, C2); RESULT.setLine(C1left); :};

ClassNameAndDerivation ::= (ClassNameAndDerivation) CLASS IDENT:className OptionalDerivation:O1 {: RESULT=new ClassNameAndDerivation(className, O1); RESULT.setLine(classNameleft); :};

ClassBody ::= (ClassBody) Class_VarDeclList:C1 Dummy_ClassBody:D2 ConstructorMethodLists:C3 {: RESULT=new ClassBody(C1, D2, C3); RESULT.setLine(C1left); :};

Dummy_ClassBody ::= (Dummy_ClassBody_) {: RESULT=new Dummy_ClassBody_(); :} /* empty */;

Class_VarDeclList ::= 	(Class_VarDeclList_) 		Class_VarDeclList:C1 Class_VarDecl:C2 {: RESULT=new Class_VarDeclList_(C1, C2); RESULT.setLine(C1left); :}
					| 	(Class_EmptyVarDeclList) {: RESULT=new Class_EmptyVarDeclList(); :} 	/* empty */
					;

OptionalDerivation ::= 	(OptionalDerivation_) 	EXTENDS Type:T1 {: RESULT=new OptionalDerivation_(T1); RESULT.setLine(T1left); :}
					|	(NoDerivation) {: RESULT=new NoDerivation(); :} 			/* empty */
					|	(ClassDerivation) 		error:l {: parser.report_error("Greska pri parsiranju deklaracije prosirenja natklase u liniji: " + lleft, null); :} {: RESULT=new ClassDerivation(); :}
					;
				
ConstructorMethodLists ::= 	(ConstructorMethodLists_) 		LBRACE ClassMethodConstructorLists:C1 RBRACE {: RESULT=new ConstructorMethodLists_(C1); RESULT.setLine(C1left); :} 
						|	(EmptyConstructorMethodLists) {: RESULT=new EmptyConstructorMethodLists(); :} 	/* empty */
						;

/* resolving method-constructor parsing conflict  */
ClassMethodConstructorLists ::= (ConstructorsAndMethods_Ident) 	IDENT:I1 LPAREN ConstructorDeclList:C2 IDENT:I3 IDENT:I4 LPAREN MethodDeclList:M5 {: RESULT=new ConstructorsAndMethods_Ident(I1, C2, I3, I4, M5); RESULT.setLine(I1left); :} 
							 | 	(ConstructorsAndMethods_Void) 	IDENT:I1 LPAREN ConstructorDeclList:C2 VOID IDENT:I3 LPAREN MethodDeclList:M4 {: RESULT=new ConstructorsAndMethods_Void(I1, C2, I3, M4); RESULT.setLine(I1left); :} 
							 | 	(Constructors) 					IDENT:I1 LPAREN ConstructorDeclList:C2 {: RESULT=new Constructors(I1, C2); RESULT.setLine(I1left); :} 
							 | 	(Methods_Ident) 				IDENT:I1 IDENT:I2 LPAREN MethodDeclList:M3 {: RESULT=new Methods_Ident(I1, I2, M3); RESULT.setLine(I1left); :}
							 | 	(Methods_Void) 					VOID IDENT:I1 LPAREN MethodDeclList:M2 {: RESULT=new Methods_Void(I1, M2); RESULT.setLine(I1left); :}
							 | 	(EmptyClassMethodConstructorLists) {: RESULT=new EmptyClassMethodConstructorLists(); :} /* empty */
							 ;

MethodDeclList ::= (MethodDeclList_Ident) 	MethodDeclList:M1 IDENT:I2 IDENT:I3 LPAREN MethodDecl:M4 {: RESULT=new MethodDeclList_Ident(M1, I2, I3, M4); RESULT.setLine(M1left); :}
				 | (MethodDeclList_Void) 	MethodDeclList:M1 VOID IDENT:I2 LPAREN MethodDecl:M3 {: RESULT=new MethodDeclList_Void(M1, I2, M3); RESULT.setLine(M1left); :}
				 | (OneMethodDecl) 			MethodDecl:M1 {: RESULT=new OneMethodDecl(M1); RESULT.setLine(M1left); :}
				 ;

ConstructorDeclList ::= (ConstructorDeclList_) 	ConstructorDeclList:C1 IDENT:I2 LPAREN ConstructorDecl:C3 {: RESULT=new ConstructorDeclList_(C1, I2, C3); RESULT.setLine(C1left); :}
					  |	(NoConstructorDeclList) ConstructorDecl:C1 {: RESULT=new NoConstructorDeclList(C1); RESULT.setLine(C1left); :}
					  ;
						
/****** ConstructorDecl *****/

/* note that IDENT LPAREN is already parsed */
ConstructorDecl ::= FormParsOptional:F1 RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstructorDeclDerived1(F1, V2, S3); RESULT.setLine(F1left); :};

VarDeclList ::= (VarDeclList_) 				VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclList_(V1, V2); RESULT.setLine(V1left); :}
			| 	(EmptyClassVarDeclList) {: RESULT=new EmptyClassVarDeclList(); :} 	/* empty */
			;

FormParsOptional ::= 	(FormPars_) 	FormPars:F1 {: RESULT=new FormPars_(F1); RESULT.setLine(F1left); :}
					| 	(NoFormPars) {: RESULT=new NoFormPars(); :} 	/* empty */
					;
					
StatementList ::= (StatementList_) 		StatementList:S1 Statement:S2 {: RESULT=new StatementList_(S1, S2); RESULT.setLine(S1left); :}
				| (EmptyStatementList) {: RESULT=new EmptyStatementList(); :} 	/* emptt */
				;

/****** MethodDecl **********/

/* note that IDENT/VOID IDENT LPAREN is already parsed */
MethodDecl ::= FormParsOptional:F1 RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDeclDerived1(F1, V2, S3); RESULT.setLine(F1left); :}; 

/************ FormPars ********/

FormPars ::= (FormPars) OneFormPar:O1 TypeIdentList:T2 {: RESULT=new FormPars(O1, T2); RESULT.setLine(O1left); :};

OneFormPar ::= 	(OneFormPar_) Type:T1 IDENT:I2 OptionalSquare:O3 {: RESULT=new OneFormPar_(T1, I2, O3); RESULT.setLine(T1left); :}
			|	(ERROR_OneFormPar) error:l {: parser.report_error("Greska pri deklaraciji formalnog parametra funkcije u liniji " + lleft, null); :} {: RESULT=new ERROR_OneFormPar(); :}
			;
					
TypeIdentList ::= (TypeIdentList_) 		TypeIdentList:T1 COMMA OneFormPar:O2 {: RESULT=new TypeIdentList_(T1, O2); RESULT.setLine(T1left); :}
				| (EmptyTypeIdentList) {: RESULT=new EmptyTypeIdentList(); :} 	/* empty */
				;
				  
/******** Type *****/

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};

/******** Statement ********/

Statement ::= (Matched_) Matched:M1 {: RESULT=new Matched_(M1); RESULT.setLine(M1left); :}
			| (Unmatched_) Unmatched:U1 {: RESULT=new Unmatched_(U1); RESULT.setLine(U1left); :}
			;
			  
Unmatched ::= (U_If) 		IF LPAREN ConditionIf:C1 RPAREN Statement:S2 {: RESULT=new U_If(C1, S2); RESULT.setLine(C1left); :}
			| (U_IfElse) 	IF LPAREN ConditionIf:C1 RPAREN Matched:M2 ELSE Unmatched:U3 {: RESULT=new U_IfElse(C1, M2, U3); RESULT.setLine(C1left); :}
			;

Matched ::= (M_Designator) 	DesignatorStatement:D1 {: RESULT=new M_Designator(D1); RESULT.setLine(D1left); :}
		|	(M_IfElse) 		IF LPAREN ConditionIf:C1 RPAREN Matched:M2 ELSE Matched:M3 {: RESULT=new M_IfElse(C1, M2, M3); RESULT.setLine(C1left); :} 
		|	(M_While) 		WHILE LPAREN ConditionWhile:C1 RPAREN Statement:S2 {: RESULT=new M_While(C1, S2); RESULT.setLine(C1left); :} 
		|	(M_Break) 		BREAK SEMICOLON {: RESULT=new M_Break(); :} 
		|	(M_Continue) 	CONTINUE SEMICOLON {: RESULT=new M_Continue(); :} 
		|	(M_Return) 		RETURN OptionalExpr:O1 SEMICOLON {: RESULT=new M_Return(O1); RESULT.setLine(O1left); :} 
		|	(M_Read) 		READ LPAREN Designator:D1 RPAREN SEMICOLON {: RESULT=new M_Read(D1); RESULT.setLine(D1left); :} 
		|	(M_Print) 		PRINT LPAREN Expr:E1 PrintNumConst:P2 RPAREN SEMICOLON {: RESULT=new M_Print(E1, P2); RESULT.setLine(E1left); :} 
		|	(M_Foreach) 	DesignatorForeach:D1 IDENT:I2 LAMBDA Statement:S3 RPAREN SEMICOLON {: RESULT=new M_Foreach(D1, I2, S3); RESULT.setLine(D1left); :} 
		|	(M_Block) 		LBRACE StatementList:S1 RBRACE {: RESULT=new M_Block(S1); RESULT.setLine(S1left); :}
		;	

DesignatorForeach ::= (DesignatorForeach) IDENT:I1 IdentExprList:I2 DOT FOREACH LPAREN {: RESULT=new DesignatorForeach(I1, I2); RESULT.setLine(I1left); :};
				 
OptionalExpr ::= (OptionalExpr_) 	Expr:E1 {: RESULT=new OptionalExpr_(E1); RESULT.setLine(E1left); :} 
			|	 (NoExpr) {: RESULT=new NoExpr(); :} 			/* empty */
			;
				 
PrintNumConst ::= (PrintNumConst_) 	COMMA NUM_CONST:N1 {: RESULT=new PrintNumConst_(N1); RESULT.setLine(N1left); :} 
				| (NoPrintNumConst) {: RESULT=new NoPrintNumConst(); :} /* empty */
				;

/************** DesignatorStatement ***************/

DesignatorStatement ::= (DesignatorWithOptions) 	Designator:D1 DesignatorOptions:D2 SEMICOLON {: RESULT=new DesignatorWithOptions(D1, D2); RESULT.setLine(D1left); :} 
					|	(DesignatorWithSquare) 		LSQUARE OptionalDesignatorList:O1 RSQUARE EQ Designator:D2 SEMICOLON {: RESULT=new DesignatorWithSquare(O1, D2); RESULT.setLine(O1left); :} 
					|	(ERROR_DesignatorStatement) error SEMICOLON:l {: parser.report_error("Greska pri konstrukciji iskaza dodele u liniji " + lleft, null); :} {: RESULT=new ERROR_DesignatorStatement(); :}
					;
						
DesignatorOptions ::= 	(Option_Assign) 	Assignop:A1 Expr:E2 {: RESULT=new Option_Assign(A1, E2); RESULT.setLine(A1left); :}
			|  			(Option_ActPars) 	LPAREN OptionalActPars:O1 RPAREN {: RESULT=new Option_ActPars(O1); RESULT.setLine(O1left); :} 
			|  			(Option_Inc) 		INC {: RESULT=new Option_Inc(); :} 
			|  			(Option_Dec) 		DEC {: RESULT=new Option_Dec(); :}
			;  
			
OptionalDesignatorList ::= OptionalDesignator:O1 DesignatorList:D2 {: RESULT=new OptionalDesignatorListDerived1(O1, D2); RESULT.setLine(O1left); :};

OptionalActPars ::= (OptionalActPars_) 	ActPars:A1 {: RESULT=new OptionalActPars_(A1); RESULT.setLine(A1left); :}
				 |  (NoOptionalActPars) {: RESULT=new NoOptionalActPars(); :} /* empty */
				 ;
				    
OptionalDesignator ::= (OptionalDesignator_) 	Designator:D1 {: RESULT=new OptionalDesignator_(D1); RESULT.setLine(D1left); :}
					 | (NoOptionalDesignator) {: RESULT=new NoOptionalDesignator(); :} 	/* empty */
					 ;
					   
DesignatorList ::= (DesignatorList_) 		DesignatorList:D1 COMMA OptionalDesignator:O2 {: RESULT=new DesignatorList_(D1, O2); RESULT.setLine(D1left); :} 
				 | (EmptyDesignatorList) {: RESULT=new EmptyDesignatorList(); :} 	/* empty */
				 ;

/******* ActPars ********/

ActPars ::= (ActPars) Expr:E1 ExprList:E2 {: RESULT=new ActPars(E1, E2); RESULT.setLine(E1left); :};

ExprList ::= (ExprList_) 		ExprList:E1 COMMA Expr:E2 {: RESULT=new ExprList_(E1, E2); RESULT.setLine(E1left); :}
		|	 (EmptyExprList) {: RESULT=new EmptyExprList(); :} 	/* empty */
		;

/******* Condition *********/

Condition ::= (Condition) 			CondTerm:C1 Or_CondTermList:O2 {: RESULT=new Condition(C1, O2); RESULT.setLine(C1left); :};

ConditionIf ::= (ConditionIf_) 		CondTerm:C1 Or_CondTermList:O2 {: RESULT=new ConditionIf_(C1, O2); RESULT.setLine(C1left); :}
			|	(ERROR_ConditionIf) error:l {: parser.report_error("Greska pri parsiranju logickog izraza unutar IF konstrukcije u liniji: " + lleft, null); :} {: RESULT=new ERROR_ConditionIf(); :}
			;
			
ConditionWhile ::= (ConditionWhile) CondTerm:C1 Or_CondTermList:O2 {: RESULT=new ConditionWhile(C1, O2); RESULT.setLine(C1left); :};

Or_CondTermList ::= (OrCondTermList) 		Or_CondTermList:O1 OR CondTerm:C2 {: RESULT=new OrCondTermList(O1, C2); RESULT.setLine(O1left); :} 
				 |  (EmptyOrCondTermList) {: RESULT=new EmptyOrCondTermList(); :} 	/* empty */
				 ;

/******** CondTerm *********/

CondTerm ::= (CondTerm) CondFact:C1 And_CondFactList:A2 {: RESULT=new CondTerm(C1, A2); RESULT.setLine(C1left); :};

And_CondFactList ::= (AndCondFactList) 		And_CondFactList:A1 AND CondFact:C2 {: RESULT=new AndCondFactList(A1, C2); RESULT.setLine(A1left); :} 
				  |	 (EmptyAndCondFactList) {: RESULT=new EmptyAndCondFactList(); :} /* empty */
				  ;

/********* CondFact **********/

CondFact ::= (CondFact) Expr:E1 OptionalRelopExpr:O2 {: RESULT=new CondFact(E1, O2); RESULT.setLine(E1left); :};

OptionalRelopExpr ::= (OptionalRelopExpr_) 	Relop:R1 Expr:E2 {: RESULT=new OptionalRelopExpr_(R1, E2); RESULT.setLine(R1left); :} 
					| (NoOptionalRelopExpr) {: RESULT=new NoOptionalRelopExpr(); :} /* empty */
					;

/******** Expr *********/

Expr ::= (Expr) OptionalMinus:O1 Term:T2 AddopTermList:A3 {: RESULT=new Expr(O1, T2, A3); RESULT.setLine(O1left); :};

OptionalMinus ::= 	(OptionalMinus_) 	MINUS {: RESULT=new OptionalMinus_(); :}
			 	|	(NoMinus) {: RESULT=new NoMinus(); :} 			/* empty */
			 	;
			 
AddopTermList ::= (AddopTermList_) 		AddopTermList:A1 Addop:A2 Term:T3 {: RESULT=new AddopTermList_(A1, A2, T3); RESULT.setLine(A1left); :}
				| (EmptyAddopTermList) {: RESULT=new EmptyAddopTermList(); :} 	/* empty */
				;
 				  
/*********** Term *********/

Term ::= (Term) Factor:F1 MulopFactorList:M2 {: RESULT=new Term(F1, M2); RESULT.setLine(F1left); :};

MulopFactorList ::= (MulopFactorList_) 		MulopFactorList:M1 Mulop:M2 Factor:F3 {: RESULT=new MulopFactorList_(M1, M2, F3); RESULT.setLine(M1left); :}
				|	(EmptyMulopFactorList) {: RESULT=new EmptyMulopFactorList(); :} 	/* empty */
				;

/*********** Factor **********/

Factor ::= 	(F_DesignatorActPars) 	Designator:D1 OptionalActParsParen:O2 {: RESULT=new F_DesignatorActPars(D1, O2); RESULT.setLine(D1left); :} 
		|   (F_NumConst) 			NUM_CONST:N1 {: RESULT=new F_NumConst(N1); RESULT.setLine(N1left); :} 
		|   (F_CharConst) 			CHAR_CONST:C1 {: RESULT=new F_CharConst(C1); RESULT.setLine(C1left); :} 
		|   (F_BoolConst) 			BOOL_CONST:B1 {: RESULT=new F_BoolConst(B1); RESULT.setLine(B1left); :} 
		|   (F_TypeExprActPars) 	NEW Type:T1 ExprActPars:E2 {: RESULT=new F_TypeExprActPars(T1, E2); RESULT.setLine(T1left); :} 
		|   (F_Expr) 				LPAREN Expr:E1 RPAREN {: RESULT=new F_Expr(E1); RESULT.setLine(E1left); :}
		;

OptionalActParsParen ::= 	(OptionalActParsParen_) ParenWithOptionalActPars:P1 {: RESULT=new OptionalActParsParen_(P1); RESULT.setLine(P1left); :}
				 	| 		(NoActParsParen) {: RESULT=new NoActParsParen(); :} 		/* empty */
				 	;

ExprActPars ::= (ExprOrActParsExpr) 	LSQUARE Expr:E1 RSQUARE {: RESULT=new ExprOrActParsExpr(E1); RESULT.setLine(E1left); :} 
			|	(ExprOrActParsActPars) 	ParenWithOptionalActPars:P1 {: RESULT=new ExprOrActParsActPars(P1); RESULT.setLine(P1left); :}
			;
			
ParenWithOptionalActPars ::= (ParenWithOptionalActPars) LPAREN OptionalActPars:O1 RPAREN {: RESULT=new ParenWithOptionalActPars(O1); RESULT.setLine(O1left); :};

/************* Designator ************/

Designator ::= (Designator) IDENT:designatorIdentName IdentExprList:I1 {: RESULT=new Designator(designatorIdentName, I1); RESULT.setLine(designatorIdentNameleft); :};

IdentExprList ::= (IdentExprListIdent) 	IdentExprList:I1 DOT IDENT:I2 {: RESULT=new IdentExprListIdent(I1, I2); RESULT.setLine(I1left); :}
				| (IdentExprListExpr) 	IdentExprList:I1 LSQUARE Expr:E2 RSQUARE {: RESULT=new IdentExprListExpr(I1, E2); RESULT.setLine(I1left); :}
				| (EmptyIdentExprList) {: RESULT=new EmptyIdentExprList(); :} 	/* empty */
				;
				  
/************* Label ************/

Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};

/********** Assignop **********/

Assignop ::= (Assignop) EQ {: RESULT=new Assignop(); :};

/************** Relop ***************/

Relop ::= (R_Deq) 	DEQ {: RESULT=new R_Deq(); :} 
	|	  (R_Ne) 	NE {: RESULT=new R_Ne(); :} 
	|	  (R_Gt) 	GT {: RESULT=new R_Gt(); :} 
	|	  (R_Ge) 	GE {: RESULT=new R_Ge(); :} 
	|	  (R_Lt) 	LT {: RESULT=new R_Lt(); :} 
	|	  (R_Le) 	LE {: RESULT=new R_Le(); :}
	;
		  
/*********** Addop **********/

Addop ::= (A_Plus) 	PLUS {: RESULT=new A_Plus(); :}
		| (A_Minus) MINUS {: RESULT=new A_Minus(); :}
		;
		  
/*********** Mulop **********/

Mulop ::= (M_Mul) 		MUL {: RESULT=new M_Mul(); :} 
		| (M_Div) 		DIV {: RESULT=new M_Div(); :} 
		| (M_Percent) 	PERCENT {: RESULT=new M_Percent(); :}
		;
